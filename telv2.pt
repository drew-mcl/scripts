# -*- coding: utf-8 -*-
# Copyright (c) 2025, Sky Net Systems
# GNU General Public License v3.0+ (see LICENSES/GPL-3.0-or-later.txt or https://www.gnu.org/licenses/gpl-3.0.txt)
# SPDX-License-Identifier: GPL-3.0-or-later
"""
`skynet_reporting.py` – Modern OpenTelemetry callback plugin for **Ansible 2.14+**

Highlights
==========
* **Native TLS** – uses the system trust store (`ssl.create_default_context()`), so
  no custom CA bundle is required on RHEL / other Linux distros.
* **OpenTelemetry Semantic Conventions** – attributes prefixed with `ansible.*`,
  `host.*`, `code.*`, giving you rich service‑maps out‑of‑the‑box.
* **Resilient config** – any unknown/typo option is ignored (with a warning)
  instead of breaking plugin loading.
* **Fast & lightweight** – spans are batched with the default exporter limits;
  only a tiny in‑memory dict is used to stash task start times.
* **Debug toggle** – set `ANSIBLE_SKYNET_DEBUG_LOGGING=true` (or the ini option)
  to stream detailed state to the Ansible console.

Add to `ansible.cfg`::

    [defaults]
    callbacks_enabled = skynet_reporting
    callback_plugins  = ./callback_plugins

    [callback_skynet_reporting]
    endpoint  = https://otel‑collector.internal:4317
    neuron_team = trading
    neuron_app  = fx‑pricing
    enable_debug_logging = true

Environment variables still take precedence (`OTEL_EXPORTER_OTLP_ENDPOINT`,
`OTEL_EXPORTER_OTLP_TRACES_PROTOCOL`, `TRACEPARENT`, etc.).
"""
from __future__ import annotations

import os
import ssl
from dataclasses import dataclass, field
from time import time_ns
from typing import Any, Dict, Optional
from os.path import basename

from ansible.errors import AnsibleError
from ansible.module_utils.ansible_release import __version__ as ansible_version
from ansible.plugins.callback import CallbackBase

try:
    from opentelemetry import trace
    from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import (
        OTLPSpanExporter as GRPCSpanExporter,
    )
    from opentelemetry.exporter.otlp.proto.http.trace_exporter import (
        OTLPSpanExporter as HTTPSpanExporter,
    )
    from opentelemetry.propagate import get_global_textmap
    from opentelemetry.sdk.resources import SERVICE_NAME, Resource
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.trace.export import BatchSpanProcessor
    from opentelemetry.trace import SpanKind
    from opentelemetry.trace.status import Status, StatusCode

    _HAS_OTEL = True
except ImportError as exc:  # pragma: no cover – runtime guard
    _HAS_OTEL = False
    _OTEL_IMPORT_ERROR = exc

__all__ = ["CallbackModule"]

# ---------------------------------------------------------------------------
# Mandatory Ansible metadata (DOCUMENTATION / EXAMPLES)
# ---------------------------------------------------------------------------
# NOTE: Options declared here are what make `get_option()` work. If an option
#       is missing from this YAML block Ansible **will not pass it** from the
#       config file → plugin.
DOCUMENTATION = r"""
callback: skynet_reporting
short_description: High‑signal OpenTelemetry traces for every Ansible task.
version_added: "1.0.0"
author: Drew Mclachlan <drew@skynet.systems>
description:
  - Sends one span per task per host to an OTLP collector using the system CA
    trust store (gRPC or HTTP/Protobuf).
options:
  endpoint:
    type: str
    description: OTLP collector endpoint (e.g. C(https://otel.internal:4317)).
    ini:
      - section: callback_skynet_reporting
        key: endpoint
    env:
      - name: OTEL_EXPORTER_OTLP_ENDPOINT
  neuron_team:
    type: str
    description: Team responsible for the run (for service name).
    ini:
      - section: callback_skynet_reporting
        key: neuron_team
    env: [NEURON_TEAM]
  neuron_app:
    type: str
    description: Application being deployed (for service name).
    ini:
      - section: callback_skynet_reporting
        key: neuron_app
    env: [NEURON_APP]
  traceparent:
    type: str
    description: W3C traceparent header to link with upstream trace.
    env: [TRACEPARENT]
  enable_debug_logging:
    type: bool
    default: false
    description: Emit verbose plugin logs (requires -vv or higher).
    ini:
      - section: callback_skynet_reporting
        key: enable_debug_logging
    env: [ANSIBLE_SKYNET_DEBUG_LOGGING]
"""

EXAMPLES = r"""
# ansible.cfg
[defaults]
callbacks_enabled = skynet_reporting
callback_plugins  = ./callback_plugins

[callback_skynet_reporting]
endpoint = https://otel.internal:4317
neuron_team = trading
neuron_app  = fx-pricing
enable_debug_logging = true
"""

# ---------------------------------------------------------------------------
# Helper dataclasses
# ---------------------------------------------------------------------------
@dataclass
class _TaskKey:
    task_uuid: str
    host_uuid: str

    def __hash__(self):
        return hash((self.task_uuid, self.host_uuid))


@dataclass
class _TaskMeta:
    span_name: str
    start_ns: int
    attrs: Dict[str, Any] = field(default_factory=dict)


# ---------------------------------------------------------------------------
# Configuration resolver
# ---------------------------------------------------------------------------
class _Config:
    """Resolve ini → env → defaults with graceful fall‑backs."""

    def __init__(self, cb: "CallbackModule"):
        self._cb = cb

    # Generic accessor -----------------------------------------------------
    def _opt(self, key: str, default: Any = None) -> Any:
        try:
            val = self._cb.get_option(key)
        except Exception:  # unknown key / AnsibleOptionError
            return default
        return val if val not in (None, "") else default

    # Convenience wrappers --------------------------------------------------
    @property
    def endpoint(self) -> Optional[str]:
        return self._opt("endpoint") or os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT")

    @property
    def protocol(self) -> str:
        return os.getenv("OTEL_EXPORTER_OTLP_TRACES_PROTOCOL", "grpc").lower()

    @property
        @property
    def team(self) -> str:
        return str(self._opt("neuron_team", "unknown_team"))

    @property
    def app(self) -> str:
        return str(self._opt("neuron_app", "unknown_app"))(self) -> str:
        return self._opt("neuron_app", "unknown_app")

    @property
    def traceparent(self) -> Optional[str]:
        return self._opt("traceparent")

    @property
    def debug(self) -> bool:
        env_flag = os.getenv("ANSIBLE_SKYNET_DEBUG_LOGGING", "false").lower() == "true"
        return str(self._opt("enable_debug_logging", env_flag)).lower() == "true"


# ---------------------------------------------------------------------------
# Main callback plugin
# ---------------------------------------------------------------------------
class CallbackModule(CallbackBase):
    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = "notification"
    CALLBACK_NAME = "skynet_reporting"
    CALLBACK_NEEDS_ENABLED = True

    # ------------------------------------------------------------------
    # Ansible lifecycle hooks
    # ------------------------------------------------------------------
    def __init__(self, display=None):  # noqa: D401 (Ansible signature)
        super().__init__(display=display)
        if not _HAS_OTEL:
            raise AnsibleError(
                "OpenTelemetry libraries missing – `pip install opentelemetry-sdk opentelemetry-exporter-otlp grpcio`"
            ) from _OTEL_IMPORT_ERROR

        self.cfg: Optional[_Config] = None
        self.tracer_provider: Optional[TracerProvider] = None
        self.tracer = None
        self.root_span = None
        self._pending: Dict[_TaskKey, _TaskMeta] = {}
        self._failed = 0

    # Utility ------------------------------------------------------------
    def _dbg(self, msg: str):
        if self.cfg and self.cfg.debug:
            self._display.v(f"[skynet_reporting] {msg}")

    def set_options(self, task_keys=None, var_options=None, direct=None):  # noqa: N802
        super().set_options(task_keys=task_keys, var_options=var_options, direct=direct)
        self.cfg = _Config(self)
        if self.cfg.debug:
            self._display.banner("[skynet_reporting] Debug logging enabled")

    # OpenTelemetry bootstrap -------------------------------------------
    def _ensure_tracer(self):
        if self.tracer or not self.cfg:
            return
        if not self.cfg.endpoint:
            self._display.warning("[skynet_reporting] No OTLP endpoint – spans will not be exported.")
            return

        resource = Resource.create({SERVICE_NAME: f"ansible.skynet.{self.cfg.team}.{self.cfg.app}"})
        self.tracer_provider = TracerProvider(resource=resource)

        if self.cfg.protocol == "grpc":
            creds = ssl.create_default_context()  # uses system CA bundle
            exporter = GRPCSpanExporter(endpoint=self.cfg.endpoint, credentials=creds)
        elif self.cfg.protocol in {"http", "http/protobuf"}:
            exporter = HTTPSpanExporter(endpoint=self.cfg.endpoint)
        else:
            self._display.warning(f"[skynet_reporting] Unsupported protocol '{self.cfg.protocol}'.")
            return

        self.tracer_provider.add_span_processor(BatchSpanProcessor(exporter))
        trace.set_tracer_provider(self.tracer_provider)
        self.tracer = trace.get_tracer(__name__, ansible_version)
        self._dbg("Tracer initialised.")

    # Playbook start -----------------------------------------------------
    def v2_playbook_on_start(self, playbook):  # noqa: N802
        self._ensure_tracer()
        if not self.tracer:
            return

        name = basename(playbook._file_name)
        carrier = {"traceparent": self.cfg.traceparent} if self.cfg and self.cfg.traceparent else None
        parent_ctx = get_global_textmap().extract(carrier) if carrier else trace.INVALID_SPAN_CONTEXT

        self.root_span = self.tracer.start_span(
            name=f"playbook:{name}", kind=SpanKind.SERVER, context=parent_ctx
        )
        self.root_span.set_attribute("ansible.playbook.name", name)
        self.root_span.set_attribute("ansible.version", ansible_version)
        self.root_span.set_attribute("neuron.team", self.cfg.team)
        self.root_span.set_attribute("neuron.app", self.cfg.app)
        self._dbg(f"Root span created for '{name}'.")

    # Task start ---------------------------------------------------------
    def v2_playbook_on_task_start(self, task, is_conditional):  # noqa: N802
        if not self.root_span:
            return
        for host in task._hosts:
            key = _TaskKey(task._uuid, host._uuid)
            self._pending[key] = _TaskMeta(
                span_name=f"{task.get_name()} on {host.name}",
                start_ns=time_ns(),
                attrs={
                    "ansible.task.name": task.get_name(),
                    "ansible.task.action": task.action,
                    "code.filepath": task.get_path(),
                    "host.name": host.name,
                },
            )

    # Internal helper to close spans ------------------------------------
        # Internal helper to close spans ------------------------------------
    def _finish(self, result, status: str):
        if not self.root_span:
            return
        task, host = result._task, result._host
        key = _TaskKey(task._uuid, host._uuid)
        meta = self._pending.pop(key, None)
        if not meta:  # shouldn’t happen but guard anyway
            meta = _TaskMeta(span_name=f"{task.get_name()} on {host.name}", start_ns=time_ns())

        # Safely interrogate `result._result`, which is *usually* a dict but can be
        # a raw AnsibleUnicode/string for some callback events (e.g. include).
        res = result._result if isinstance(result._result, dict) else {}
        changed = bool(res.get("changed")) if isinstance(res, dict) else False

        meta.attrs.update({
            "ansible.task.status": status,
            "ansible.result.changed": changed,
        })

        ctx = trace.set_span_in_context(self.root_span)
        span = self.tracer.start_span(
            meta.span_name,
            kind=SpanKind.INTERNAL,
            context=ctx,
            start_time=meta.start_ns,
        )
        for k, v in meta.attrs.items():
            span.set_attribute(k, v)

        # Failure / skip handling ---------------------------------------
        if status == "failed":
            self._failed += 1
            msg = res.get("msg") if isinstance(res, dict) else str(result._result)
            span.record_exception(Exception(msg or "task failed"))
            span.set_status(Status(StatusCode.ERROR))
        elif status == "skipped":
            span.set_status(Status(StatusCode.UNSET))
        else:
            span.set_status(Status(StatusCode.OK))
        span.end()

    # Runner hooks --------------------------------------------------------
    def v2_runner_on_ok(self, result):  # noqa: N802
        self._finish(result, "ok")

    def v2_runner_on_failed(self, result, ignore_errors=False):  # noqa: N802
        self._finish(result, "ignored" if ignore_errors else "failed")

    def v2_runner_on_skipped(self, result):  # noqa: N802
        self._finish(result, "skipped")

(self, result):  # noqa: N802
        self._finish(result, "ok")

    def v2_runner_on_failed(self, result, ignore_errors=False):  # noqa: N802
        self._finish(result, "ignored" if ignore_errors else "failed")

    def v2_runner_on_skipped(self, result):  # noqa: N802
        self._finish(result, "skipped")

    # Playbook end --------------------------------------------------------
    def v2_playbook_on_stats(self, stats):  # noqa: N802
        if not self.root_span:
            return
        if self._failed:
            self.root_span.set_status(Status(StatusCode.ERROR, f"{self._failed} task(s) failed"))
        else:
            self.root_span.set_status(Status(StatusCode.OK))
        self.root_span.end()
        self._dbg("Root span ended – flushing exporter.")
        if self.tracer_provider:
            self.tracer_provider.force_flush()
        self._dbg("Flush complete.")
